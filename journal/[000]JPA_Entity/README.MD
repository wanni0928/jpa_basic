# JPA에서 가장 중요한 2가지

1. 객체와 관계형 데이터베이스 매핑하기
(Object Relational Mapping)

2. 영속성 컨텍스트

## 영속성 컨텍스트
- JPA를 이해하는데 가장 중요한 용어
- "엔티티를 영구 저장하는 환경"
- `EntityManager.persist(entity);`

## 엔티티 매니저? 영속성 컨텍스트?
- 영속성 컨텍스트는 논리적인 개념
- 눈에 보이지 않는다.
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근
 
## J2SE 환경
엔티티 매니저와 영속성 컨텍스트가 1:1

## J2EE, 스프링 프레임워크와 같은 컨테이너 환경
엔티티 매니저와 영속성 컨텍스트가 N:1

## 엔티티의 생명주기
- 비영속 (new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속 (managed) : 영속성 컨텍스트에 관리되는 상태
- 준영속 (detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 (removed) : 삭제된 상태

### 비영속
: 아무것도 아닌 상태

### 영속
: persist 에 집어넣은 상태

### 준영속, 삭제

## 영속성 컨텍스트의 이점
- 1차 캐시 : 한번 조회한건 쿼리로 날아가지 않는다.(동일한 트랜잭션 안에서)
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연 : 버퍼링 - `write`을 모았다가 한번에 `write`
- 변경 감지(Dirty Checking) : update 할때, JPA가 자동으로 인식해서 flush 해주는 것.
- 지연 로딩(Lazy Loading)

## 엔티티 조회, 1차캐시
1차 캐시 : 한번 조회한건 쿼리로 날아가지 않는다.(동일한 트랜잭션 안에서)

# 플러시
영속성 컨텍스트의 변경내용을 데이터베이스에 반영.

## 플러시 발생
- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리슷 데이터베이스에 전송 (등록, 수정, 삭제 쿼리)

## 플러시 모드 옵션
```java
em.setFlushMode(flushModeType.COMMIT);
```

- `FlushModeType.AUTO` : 커밋이나 쿼리를 실행할 때 플러시 (기본값, 거의 이것만 씀)
- `FlushModeType.COMMIT` : 커밋할 때만 플러시 (활용성 거의 0)

## 플러시는!
- 영속성 컨텍스트를 비우지 않는다.
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화
- 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면 됨.

# 준영속 상태
- 영속 -> 준영속
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached).
- 영속성 컨텍스트가 제공하는 기능을 사용 못함.

## 준영속 상태로 만드는 방법
```java
// 특정 엔티티만 준영속 상태로 전환
em.detach(entity);
```

```java
// 영속성 컨텍스트를 완전히 초기화
em.clear();
```

```java
// 영속성 컨텍스트를 종료
em.close();
```